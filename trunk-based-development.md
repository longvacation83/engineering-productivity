> 本文内容主要参考以下内容（同时融入了自己的研发实践）：
> * <https://trunkbaseddevelopment.com/>
> * <https://cloud.google.com/architecture/devops/devops-tech-trunk-based-development?hl=zh-cn>
> 
> 本文默认代码的版本管理工具（Source Control Management）为Git <https://git-scm.com/>。

## 主干开发模式
英文单词Trunk翻译为中文是“树干”。Trunk Based Development（TBD）是一种代码仓库的分支管理策略，命名为`主干开发模式`。团队成员在约定的主干分支上（如`master`分支）协作，进行代码修改提交。相比分支开发模式（Feature Based Development，例如GitFlow等），TBD避免在多个长生命周期分支并行开发，鼓励在同一主干分支上快速修改提交，更适合软件研发中的持续集成（CI，Continuous Integration）和持续交付（CD，Continuous Delivery）实践。

![image](https://user-images.githubusercontent.com/12379685/190977449-e40a3fac-d540-4625-a1ec-e42de047d078.png)

## 为什么？

> 为什么提倡主干开发模式？为什么有不少项目使用分支开发模式？

上面两个问题暂不直接回答，但值得每个人去思考。分支开发模式之所以存在，必然有其合理性。

考虑这样一个场景，一个软件项目包含若干模块，一个团队维护这个项目，同一个模块有若干研发维护。假设项目采用敏捷开发，两周发布一个迭代。一个迭代包含若干功能，不同功能开发成本不同（修改可小可大）。在这种情况下，可能会存在大家修改同一模块的情况，存在代码修改冲突，为了减轻相互间的影响，团队可能会创建功能分支，在各分支进行开发，在发布前将各分支合并到同一（主干）分支，并处理冲突。

![image](https://user-images.githubusercontent.com/12379685/191155353-1b05cbea-1f14-414d-bc09-f17189fe5c94.png)


从上述场景看，分支开发也有其存在的合理性。每个功能的研发在各自的分支上开发，然后进行合并。但与此同时也引入了其他问题，比如：

* 软件项目中模块具有内聚性，有统一的设计与实现，并持续进行迭代，必要时进行重构。假设模块M需要开发两个功能A和B，有可能A和B依赖同样的基础设施，假设A和B由同一个研发开发，该研发可以将A和B中共性功能做统一规划，避免重复建设；但如果A和B由不同的人开发，为了方便和赶时间，A和B之间可能不会交流，各自采用局部成本最低的方式实现功能，这很可能造成模块M的实现劣化，内聚性越来越差。

* 使用分支开发因为相互间实现了隔离，这样间接鼓励研发按照敏捷迭代的功能划分和周期，进行长时间的较大的修改。但你有没有想过，迭代中的功能划分是否合理？业务&产品视角的划分，是否和研发视角的划分一致？

## TBD的本质

### 隔离和解耦

为了降低软件开发的复杂度，软件研发技术中”隔离“和“解耦”的思路到处可见，无论是代码文件还是函数，分层设计，模块，面向对象，以及微服务等。TBD其实也是一种在软件协同中，针对代码管理流程实现隔离&解耦的技术。如果你的一次修改足够小足够快，你的工作很可能对他人造成的影响更小，也更容易被他人审核验证。

如果发现有大量人在同一个项目中开发，采用主干开发冲突太多，或许你应该考虑的不是调整分支管理策略，而是思考下是否需要对项目进行（微服务）拆分？如果你要进行一次功能开发，涉及大量代码的修改，是否可以将修改（按照一定的逻辑）拆分，将一次大修改转化为若干次小修改？

> 左耳朵耗子：
> “与其花时间在 Git 协同工作流上，还不如把时间花在调整软件架构和自动化软件生产和运维流程上来，这才是真正简化协同工作流程的根本。”

![image](https://user-images.githubusercontent.com/12379685/191154040-f75ef348-c2e6-4692-b4e2-590ea1c4176c.png)


> Google虽然90%以上的代码都放在名叫`Piper`的单一代码仓库中（monorepo），但每个团队有各自的目录，每个目录有负责人（owner），负责批准该目录的文件变动。Google代码仓库虽然巨大，但是根据目录进行隔离解耦的。
> 
> 随着Git等分布式版本控制系统（DVCS）的兴起，Google已经开始考虑放弃Piper，采用Git作为他们的主要版本控制系统。Git社区建议开发人员使用更多以及规模更小的代码库。一个Git-clone的操作需要将所有内容复制到本地机器，这对于使用大规模代码库的开发人员来说是不可能的事情。
> 
> 要想开始使用基于Git的资源托管服务，Google必须将他们的代码库进行拆分，变成上千个独立的代码库。这样的重构 将会给谷歌开发人员带来企业文化和工作流程双方面的改变。例如谷歌的安卓代码库，就独立于他们的主代码库，被分成了超过800个独立的代码库。鉴于Google从当前模式中已经获得了诸多好处，很明显他们并不会对自己的代码库进行拆分。
> 
> 微软在使用Git时遇到了同样的问题，Windows 和 Office代码仓库规模非常巨大（monorepo），这意味着一个简单的操作（比如checkout）都可能花费3小时或以上。将 Windows 代码库拆分成合适大小的子代码库这条路也行不通。假如当初一开始的时候就是这么做的，那还有可能，可是到现在代码库已经这么大了，而且又发展了这么久，要再想回头把它拆分开，这事实上并不可能了。为了解决这个问题，催生了Git虚拟文件系统（Git Virtual File System，GVFS）。

![image](https://user-images.githubusercontent.com/12379685/191153595-8957289f-fd36-4f4e-a6a2-5e66a536cfb5.png)


### 提速，再提速

> CI/CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI/CD 的核心概念是持续集成、持续交付和持续部署。作为一个面向开发和运营团队的解决方案，CI/CD 主要针对在集成新代码时所引发的问题（亦称："集成地狱"）。

很多公司使用的版本管理工具是Git，同时使用GitLab作为Git配套的Web端管理工具和DevOps平台。通过配置`.gitlab-ci.yml`可以很方便的开启持续集成&交付，实现代码提交后的静态扫描，编译，测试集验证，以及上线部署等流程。

CI/CD的理念是小步快行：快速修改，快速验证，快速部署。标准化的研发流程可以引入很多环节（比如：产品调研需求->进行需求评审/UI设计->技术评审->需求反串讲->开发->测试->验收->UAT/用户培训->上线），如果研发时间太长，长期看不到投入产出和反馈，无论对需求方，还是产研团队都是一种慢性损耗。

在主干开发模式下，团队成员一天多次将代码提交到主干分支，满足持续交付的必要条件；团队的工作也可以快速被整合，保证代码版本随时处于可发布状态，使得持续交付成为可能。

![image](https://user-images.githubusercontent.com/12379685/190990697-fb67a620-ed93-4301-a1b7-d7eb154e5783.png)

CI/CD的理念对于面向C端的网络服务尤为重要：无论是从满足用户新需求，解决用户遇到问题，提升用户体验以便保持快速增长占领市场份额的角度；还是从提升企业内部研发效率和组织管理水平，以应对快速变化的市场角度，CI/CD都是最佳的选择。

实际上即便是B端软件开发（比如目前常被提到的企业信息化/数字化系统等），快速迭代上线也是研发团队亟需的核心能力。企业信息化系统是企业战略和流程管理的体现，战略的执行强调强执行力。想要真正提升研发管理水平和软件质量，代码管理是重点。研发管理从宏观角度无论管理理念如何先进，无法落实到围绕代码质量的流程建设，最终都会事倍功半。

> 根据笔者同业务方交流的经验，B端软件（比如典型的如飞书）不强调交互的个性化，更强调使用体验的标准化和流畅性。经常遇到的一个尴尬场景，是业务方提了一个并不复杂的需求，但由于能力或资源的限制，产研团队评估后往往会给业务方一个很夸张的人天预估（比如按照现有人力看起来最多一周的工作，评估了1个月），导致业务方的信息化实施热情被极大的打击。往往系统经过长期开发后，交付给业务方的是一个充斥大量bug的系统，根本没法使用，或者业务方发现系统并不是他们想要的效果（在开发中经常出现这种情况），导致系统刚开发完成就被弃用。另外B端系统开发中经常会引入外包团队（人员外包或项目外包），通过短时间引入大量人力的方式，尝试提升研发速度。但外包引入尝尝带来人员管理的额外成本，培训&融入需要花费大量时间，且外包人员平均水平较差，代码质量最终会不断劣化，后续迭代速度难以提升。

### 灵活的分支管理

- 在TBD模式中，根据团队规模&发布频率的不同，同样允许存在特性分支（Feature Branch）。但这些特性分支生命周期很短，其作用是用于代码审核（Code Review）和持续集成（CI）。对于人数较少&发布频率更高的团队，也可能不使用特性分支，直接向主干上提交。

- 可能存在release分支。release分支基于主干创建（比如使用git tag命令）。这种分支相当于在恰当时刻为主干创建了一个快照，便于进行代码的部署和回滚，以及紧急问题的修复。release分支在一段时间后往往被删除并不长期存在。因为主干代码在快速修改推进，在新的release分支创建并部署验证后，一些较为陈旧的release分支可以被删除（保留若干release分支便于快速回滚）。假如主干分支已经有了新的提交（但还不能被马上部署），同时存在线上bug需要修复，可以基于release分支进行hotfix。

- 可能短期存在develop分支。develop分支作为功能迭代分支，在一段时间内团队使用develop分支作为主干分支，所有的修改和测试都围绕develop分支进行，使用develop分支部署测试环境。当开发测试完成后，将develop分支整体合并到主干分支，并删除合并后的develop分支。在下次迭代时基于主干创建新的develop分支。

![image](https://user-images.githubusercontent.com/12379685/191157138-9d98ccf5-f015-441a-8966-3a220d121484.png)

### 为代码审查规划修改

代码写出来是给人看的，执行代码的机器不在乎代码的可读性，但维护代码的研发在乎，而TBD模式提倡的`快速修改快速验`证为代码审查提供了便利。人脑在一定时间内能够处理的复杂度有限，为了实现快速（意味着研发时间短）修改，要保证一次修改的代码量尽量的小。当修改的代码量变小时，既方便研发自己进行验证，也方便他人进行代码审查。事实上倘若修改的代码足够多，进行代码审查几乎不可能，因为那将占用其他人大量的时间来消化代码，而别人有自己的工作要完成。

当发现修改的代码数量较多，应该考虑将一次大提交拆分为若干小提交。要明白代码修改本身也是值得`规划`的，分为几次提交，每次提交修改什么，修改的代码量是否足够小等都值得认真思考。

![image](https://user-images.githubusercontent.com/12379685/191452340-bc8fcfc6-a7bd-470d-927c-889230ea9c84.png)


（未完待续...）
